#ifndef CARIBOU_TOPOLOGY_ENGINE_GRID_INTERNAL_MULTIDIMENSIONALGRID_H
#define CARIBOU_TOPOLOGY_ENGINE_GRID_INTERNAL_MULTIDIMENSIONALGRID_H

#include <Caribou/Topology/Engine/Grid/Internal/Grid.h>
#include <Caribou/Algebra/Vector.h>

namespace caribou {
namespace topology {
namespace engine {
namespace internal {

/**
 * Simple representation of a multidimensional (2D or 3D) Grid in space.
 *
 * ** Do not use this class directly. Use instead caribou::topology::engine::Grid. **
 *
 * The functions declared in this class can be used with any type of grids (static grid, container grid, etc.).
 *
 * Do to so, it uses the Curiously recurring template pattern (CRTP) :
 *    https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern
 *
 * A Grid is a set of multiple cell entities (same-length lines in 1D, rectangles
 * in 2D and rectangular hexahedrons in 3D) aligned in the x, y and z axis.
 *
 * @tparam Dim Dimension of the grid (1D, 2D or 3D).
 * @tparam GridType_ Type of the derived grid class that will implement the final functions.
 */
template <size_t Dim, class GridType_>
struct BaseMultidimensionalGrid : public BaseGrid<Dim, GridType_>
{
    static constexpr size_t Dimension = Dim;

    static_assert(Dimension == 2 or Dimension == 3, "Only grid of dimension 2 or 3 is allowed.");

    using GridType = GridType_;

    using Int = size_t;
    using Float = FLOATING_POINT_TYPE;

    using VecFloat = caribou::algebra::Vector<Dimension, Float>;
    using VecInt = caribou::algebra::Vector<Dimension, Int>;

    using Index = Int;
    using NodeIndex = Int;
    using CellIndex = Int;
    using RelativePosition = VecFloat;
    using Size = VecFloat;

    /** Default constructor is not permitted **/
    BaseMultidimensionalGrid() = delete;

    /**
     * Get the cell index at grid location (i, j, k).
     * @param grid_coordinates Cell location provided in terms of grid coordinates (i, j, k).
     * @note For performance purposes, no check is performed to ensure the grid coordinates are valid.
     */
    inline Index
    cell_index(const VecInt & grid_coordinates) const
    {
        const auto & n = Self().number_of_subdivision();

        const Index & i = grid_coordinates[0];
        const Index & j = grid_coordinates[1];
        const Index   k = (Dimension == 3) ? grid_coordinates[2] : 0;

        const Int & nx = n[0];
        const Int & ny = n[1];

        // Index is generated by looking at the cells as a flatten array
        return k*ny*nx + j*nx + i;
    }

    /** Get the grid location (i, j, k) at index cell_index */
    inline VecInt
    grid_coordinates(const CellIndex & index) const
    {
        using Int = typename VecInt::ValueType;

        const auto & n = Self().number_of_subdivision();
        const Int & nx = n[0];
        const Int & ny = n[1];

        const Index k = (Dimension == 3) ? (index / (nx*ny)) : 0;
        const Index j = (index - (k*nx*ny)) / nx;
        const Index i = index - ((k*nx*ny) + (j*nx));

        if CONSTEXPR_IF(Dimension == 2)
            return {i, j};
        else // Dimension == 3
            return {i, j, k};
    }

    /** Get the position of the node node_id relative to the grid frame (bottom-left most node). **/
    inline RelativePosition
    relative_position(const NodeIndex & index) const
    {
        const auto & n = Self().number_of_subdivision();
        const auto & nx = n[0]+1; // Number of nodes in the x direction
        const auto & ny = n[1]+1; // Number of nodes in the y direction

        const Index k = (Dimension == 3) ? (index / (nx*ny)) : 0; // Node indice in the z direction
        const Index j = (index - (k*nx*ny)) / nx; // Node indice in the y direction
        const Index i = index - ((k*nx*ny) + (j*nx)); // Node indice in the x direction

        const auto & h = Self().cell_size();
        const auto & hx = h[0]; // Width of a cell
        const auto & hy = h[1]; // Height of a cell
        const auto & hz = h[2]; // Dept of a cell

        // Relative position of the node within the grid
        const VecFloat p = (Dimension == 2) ? VecFloat({i*hx, j*hy}) : VecFloat({i*hx, j*hy, k*hz});

        return p; // Relative position
    }

private:
    inline constexpr
    const GridType &
    Self() const
    {
        return static_cast<const GridType &> (*this);
    }

};

} // namespace internal
} // namespace engine
} // namespace topology
} // namespace caribou

#endif //CARIBOU_TOPOLOGY_ENGINE_GRID_INTERNAL_MULTIDIMENSIONALGRID_H
