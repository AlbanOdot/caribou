#ifndef CARIBOU_TOPOLOGY_ENGINE_GRID_INTERNAL_GRID_H
#define CARIBOU_TOPOLOGY_ENGINE_GRID_INTERNAL_GRID_H

#include <cstddef>
#include <list>
#include <Caribou/config.h>
#include <Caribou/Algebra/Vector.h>

namespace caribou::topology::engine::internal {

/**
 * Simple representation of a Grid in space.
 *
 * ** Do not use this class directly. Use instead caribou::topology::engine::Grid. **
 *
 * The functions declared in this class can be used with any type of grids (static grid, container grid, etc.).
 *
 * Do to so, it uses the Curiously recurring template pattern (CRTP) :
 *    https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern
 *
 * A Grid is a set of multiple cell entities (same-length lines in 1D, rectangles
 * in 2D and rectangular hexahedrons in 3D) aligned in the x, y and z axis.
 *
 * @tparam Dim Dimension of the grid (1D, 2D or 3D).
 * @tparam GridType_ Type of the derived grid class that will implement the final functions.
 */
template <size_t Dim, class GridType_>
struct BaseGrid
{
    static constexpr size_t Dimension = Dim;

    using GridType = GridType_;

    using Int = size_t;
    using Float = FLOATING_POINT_TYPE;

    using VecFloat = caribou::algebra::Vector<Dimension, Float>;
    using VecInt = caribou::algebra::Vector<Dimension, Int>;

    using NodeIndex = Int;
    using CellIndex = Int;
    using Dimensions = VecFloat;
    using Subdivisions = VecInt;
    using LocalCoordinates = VecFloat;
    using WorldCoordinates = VecFloat;
    using GridCoordinates = VecInt;
    using CellSet = std::list<CellIndex>;

    static_assert(Dimension == 1 || Dimension == 2 || Dimension == 3, "Grids are only available in 1, 2 or 3 dimensions");


    /** Default constructor **/
    constexpr
    BaseGrid() = delete;

    /**
     * Main constructor of a grid
     * @param anchor_position Position of the anchor point
     * @param subdivisions Number of sub-cells in each directions of the grid.
     * @param dimension Global size of the grid.
     */
    constexpr
    BaseGrid(const WorldCoordinates & anchor_position, const Subdivisions & n, const Dimensions & size)
            : m_anchor_position(anchor_position), m_number_of_subdivisions(n), m_size(size)
    {}

    /** Get the number of cells (same-length lines in 1D, rectangles
     * in 2D and rectangular hexahedrons in 3D) in this grid. **/
    inline Int
    number_of_cells() const noexcept
    {
        const auto & n = Self().number_of_subdivision();

        if CONSTEXPR_IF(Dimension == 1)
            return n;

        if CONSTEXPR_IF(Dimension == 2)
            return n[0] * n[1];

        if CONSTEXPR_IF(Dimension == 3)
            return n[0] * n[2] * n[3];

        return 0;
    }

    /** Get the number of distinct nodes in this grid. **/
    inline Int
    number_of_nodes() const noexcept
    {
        const auto & n = Self().number_of_subdivision();

        if CONSTEXPR_IF(Dimension == 1)
            return n+1;

        if CONSTEXPR_IF(Dimension == 2)
            return (n[0]+1) * (n[1]+1);

        if CONSTEXPR_IF(Dimension == 3)
            return (n[0]+1) * (n[2]+1) * (n[3]+1);

        return 0;
    }

    /** Get the number of distinct edges in this grid. **/
    inline Int
    number_of_edges() const noexcept
    {
        const auto & n = Self().number_of_subdivision();

        if CONSTEXPR_IF(Dimension == 1)
            return n;

        if CONSTEXPR_IF(Dimension == 2)
            return n[0] * (n[1]+1) + n[1] * (n[0]+1); // nx * (ny+1)  +  ny * (nx+1)

        if CONSTEXPR_IF(Dimension == 3)
            return (n[0] * (n[1]+1) + n[1] * (n[0]+1)) * (n[2]+1) +  // Number of edges in a 2D grid * (nz+1)
                   (n[0]+1) * (n[1]+1); // Plus the number of edges in between 2D grids

        return 0;
    }

    /** Get the dimension of a cell : hx (in 1D), {hx, hy} (in 2D) or {hx, hy, hz} (in 3D) */
    inline Dimensions
    H () const noexcept
    {
        return m_size.direct_division(m_number_of_subdivisions);
    }

    /** The global dimension of this grid : hx (in 1D), {hx, hy} (in 2D) or {hx, hy, hz} (in 3D) */
    inline Dimensions
    size() const noexcept
    {
        return m_size;
    }

    /** Get the cell index at a given grid location. */
    inline CellIndex
    cell_index_at(const GridCoordinates & coordinates) const noexcept
    {
        const auto & n = m_number_of_subdivisions;

        // Index is generated by looking at the cells as a flatten array
        if constexpr (Dimension == 1) {
            const auto & i = coordinates[0];
            return i;
        } else if constexpr (Dimension == 2) {
            const auto & i = coordinates[0];
            const auto & j = coordinates[1];

            const auto &nx = n[0];

            return j * nx + i;
        } else {
            const auto & i = coordinates[0];
            const auto & j = coordinates[1];
            const auto & k = coordinates[2];

            const auto &nx = n[0];
            const auto & ny = n[1];

            return k*ny*nx + j*nx + i;
        }
    }

    /** Get the index of the cell that contains the given world coordinates. */
    inline CellIndex
    cell_index_at(const WorldCoordinates & coordinates) const noexcept
    {
        return cell_index_at(grid_coordinates_at(coordinates));
    }

    /** Get the grid location of the cell at index cell_index */
    inline GridCoordinates
    grid_coordinates_at(const CellIndex & index) const noexcept
    {
        const auto & n = m_number_of_subdivisions;

        if constexpr (Dimension == 1) {
            return index;
        } else if constexpr (Dimension == 2) {
            const auto & nx = n[0];

            const auto j = index / nx;
            const auto i = index - (j*nx);

            return {i,j};
        } else {
            const auto & nx = n[0];
            const auto & ny = n[1];

            const auto k = index / (nx*ny);
            const auto j = (index - (k*nx*ny)) / nx;
            const auto i = index - ((k*nx*ny) + (j*nx));

            return {i, j, k};
        }
    }

    /** Get the grid location of the cell that contains the given world coordinates */
    inline GridCoordinates
    grid_coordinates_at(const WorldCoordinates & coordinates) const noexcept
    {
        // @todo (jnbrunet2000@gmail.com): This test should be using inverse mapping function from a regular
        //  hexahedron geometric element defined in the geometry module.

        return (coordinates - m_anchor_position)
        .direct_division(H());
    }

    /** Test if the position of a given point is inside this grid */
    inline bool
    contains_position(const WorldCoordinates & coordinates) const noexcept
    {
        // @todo (jnbrunet2000@gmail.com): This test should be using inverse mapping function from a regular
        //  hexahedron geometric element defined in the geometry module.

        const auto distance_to_anchor = (coordinates - m_anchor_position).direct_division(size());

        if (distance_to_anchor[0] < 0 || distance_to_anchor[0] > 1)
            return false;

        if constexpr (Dimension >= 2) {
            if (distance_to_anchor[1] < 0 || distance_to_anchor[1] > 1)
                return false;
        }

        if constexpr (Dimension == 3) {
            if (distance_to_anchor[2] < 0 || distance_to_anchor[2] > 1)
                return false;
        }

        return true;
    }

    /** Returns the set of cells that enclose (in a bounding-box manner) the given world positions */
    template<typename ...WorldCoordinatesTypes>
    inline CellSet
    cells_enclosing(WorldCoordinates && first_position, WorldCoordinatesTypes && ... remaining_positions) const noexcept
    {
        std::array<WorldCoordinates , sizeof...(remaining_positions)+1> positions {{
            std::forward<WorldCoordinates>(first_position), std::forward<WorldCoordinates>(remaining_positions)...
        }};

        // First, find the grid coordinates bounding box of the cells that contain each nodes
        GridCoordinates lower_cell = grid_coordinates_at(positions[0]);
        GridCoordinates upper_cell = lower_cell;
        for (size_t i = 1; i < positions.size(); ++ i) {
            GridCoordinates coordinates = grid_coordinates_at(positions[i]);

            // Dimension 1 and up
            if (coordinates[0] < lower_cell[0])
                lower_cell[0] = coordinates[0];
            else if (coordinates[0] > upper_cell[0])
                upper_cell[0] = coordinates[0];

            // Dimension 2 and up
            if constexpr (Dimension >= 2) {
                if (coordinates[1] < lower_cell[1])
                    lower_cell[1] = coordinates[1];
                else if (coordinates[1] > upper_cell[1])
                    upper_cell[1] = coordinates[1];
            }

            // Dimension 3 and up
            if constexpr (Dimension == 3) {
                if (coordinates[2] < lower_cell[2])
                    lower_cell[2] = coordinates[2];
                else if (coordinates[2] > upper_cell[2])
                    upper_cell[2] = coordinates[2];
            }
        }

        // Next, append all cells within the bounding-box
        CellSet enclosing_cells;
        if constexpr (Dimension ==1) {
            for (CellIndex i = lower_cell[0]; i <= upper_cell[0]; ++i)
                enclosing_cells.emplace_back(cell_index_at(GridCoordinates(i)));
        } else if constexpr (Dimension == 2) {
            for (CellIndex j = lower_cell[1]; j <= upper_cell[1]; ++j)
                for (CellIndex i = lower_cell[0]; i <= upper_cell[0]; ++i)
                    enclosing_cells.emplace_back(cell_index_at(GridCoordinates({i, j})));
        } else { // Dimension == 3
            for (CellIndex k = lower_cell[2]; k <= upper_cell[2]; ++k)
                for (CellIndex j = lower_cell[1]; j <= upper_cell[1]; ++j)
                    for (CellIndex i = lower_cell[0]; i <= upper_cell[0]; ++i)
                        enclosing_cells.emplace_back(cell_index_at(GridCoordinates({i, j, k})));
        }

        return enclosing_cells;
    }

protected:
    ///< Position of the anchor point of this grid.
    const WorldCoordinates m_anchor_position;

    ///< Number of sub-cells in the x, y and z directions respectively.
    const Subdivisions m_number_of_subdivisions;

    ///<  Dimension of the grid from the anchor point in the x, y and z directions respectively.
    const Dimensions m_size;

private:
    const inline GridType &
    Self() const
    {
        return static_cast<const GridType &> (*this);
    }

};

} // namespace caribou::topology::engine::internal

#endif //CARIBOU_TOPOLOGY_ENGINE_GRID_INTERNAL_GRID_H
