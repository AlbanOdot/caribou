#ifndef CARIBOU_TOPOLOGY_ENGINE_GRID_INTERNAL_GRID_H
#define CARIBOU_TOPOLOGY_ENGINE_GRID_INTERNAL_GRID_H

#include <cstddef>
#include <Caribou/config.h>
#include <Caribou/Algebra/Vector.h>

namespace caribou {
namespace topology {
namespace engine {
namespace internal{

/**
 * Simple representation of a Grid in space.
 *
 * ** Do not use this class directly. Use instead caribou::topology::engine::Grid. **
 *
 * The functions declared in this class can be used with any type of grids (static grid, container grid, etc.).
 *
 * Do to so, it uses the Curiously recurring template pattern (CRTP) :
 *    https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern
 *
 * A Grid is a set of multiple cell entities (same-length lines in 1D, rectangles
 * in 2D and rectangular hexahedrons in 3D) aligned in the x, y and z axis.
 *
 * @tparam Dim Dimension of the grid (1D, 2D or 3D).
 * @tparam GridType_ Type of the derived grid class that will implement the final functions.
 */
template <size_t Dim, class GridType_>
struct BaseGrid
{
    static constexpr size_t Dimension = Dim;

    using GridType = GridType_;

    using Int = size_t;
    using Float = FLOATING_POINT_TYPE;

    using VecFloat = caribou::algebra::Vector<Dimension, Float>;
    using VecInt = caribou::algebra::Vector<Dimension, Int>;

    using NodeIndex = Int;
    using CellIndex = Int;
    using Dimensions = VecFloat;
    using Subdivisions = VecInt;
    using LocalCoordinates = VecFloat;
    using WorldCoordinates = VecFloat;
    using GridCoordinates = VecInt;

    /** Default constructor **/
    constexpr
    BaseGrid() = delete;

    /**
     * Main constructor of a grid
     * @param anchor_position Position of the anchor point
     * @param subdivisions Number of sub-cells in each directions of the grid.
     * @param dimension Global size of the grid.
     */
    constexpr
    BaseGrid(const WorldCoordinates & anchor_position, const Subdivisions & n, const Dimensions & size)
            : m_anchor_position(anchor_position), m_number_of_subdivisions(n), m_size(size)
    {}

    /** Get the number of cells (same-length lines in 1D, rectangles
     * in 2D and rectangular hexahedrons in 3D) in this grid. **/
    inline Int
    number_of_cells() const noexcept
    {
        const auto & n = Self().number_of_subdivision();

        if CONSTEXPR_IF(Dimension == 1)
            return n;

        if CONSTEXPR_IF(Dimension == 2)
            return n[0] * n[1];

        if CONSTEXPR_IF(Dimension == 3)
            return n[0] * n[2] * n[3];

        return 0;
    }

    /** Get the number of distinct nodes in this grid. **/
    inline Int
    number_of_nodes() const noexcept
    {
        const auto & n = Self().number_of_subdivision();

        if CONSTEXPR_IF(Dimension == 1)
            return n+1;

        if CONSTEXPR_IF(Dimension == 2)
            return (n[0]+1) * (n[1]+1);

        if CONSTEXPR_IF(Dimension == 3)
            return (n[0]+1) * (n[2]+1) * (n[3]+1);

        return 0;
    }

    /** Get the number of distinct edges in this grid. **/
    inline Int
    number_of_edges() const noexcept
    {
        const auto & n = Self().number_of_subdivision();

        if CONSTEXPR_IF(Dimension == 1)
            return n;

        if CONSTEXPR_IF(Dimension == 2)
            return n[0] * (n[1]+1) + n[1] * (n[0]+1); // nx * (ny+1)  +  ny * (nx+1)

        if CONSTEXPR_IF(Dimension == 3)
            return (n[0] * (n[1]+1) + n[1] * (n[0]+1)) * (n[2]+1) +  // Number of edges in a 2D grid * (nz+1)
                   (n[0]+1) * (n[1]+1); // Plus the number of edges in between 2D grids

        return 0;
    }

    /** Get the dimension of a cell : hx (in 1D), {hx, hy} (in 2D) or {hx, hy, hz} (in 3D) */
    inline Dimensions
    H () const noexcept
    {
        return m_size.direct_division(m_number_of_subdivisions);
    }

    /** The global dimension of this grid : hx (in 1D), {hx, hy} (in 2D) or {hx, hy, hz} (in 3D) */
    inline Dimensions
    size() const noexcept
    {
        return m_size;
    }

    /** Get the cell index at a given grid location. */
    inline CellIndex
    cell_index_at(const GridCoordinates & coordinates) const noexcept
    {
        const auto & n = m_number_of_subdivisions;

        // Index is generated by looking at the cells as a flatten array
        if constexpr (Dimension == 1) {
            const auto & i = coordinates[0];
            return i;
        } else if constexpr (Dimension == 2) {
            const auto & i = coordinates[0];
            const auto & j = coordinates[1];

            const auto &nx = n[0];

            return j * nx + i;
        } else {
            const auto & i = coordinates[0];
            const auto & j = coordinates[1];
            const auto & k = coordinates[2];

            const auto &nx = n[0];
            const auto & ny = n[1];

            return k*ny*nx + j*nx + i;
        }
    }

    /** Get the grid location of the cell at index cell_index */
    inline GridCoordinates
    grid_coordinates_at(const CellIndex & index) const noexcept
    {
        const auto & n = m_number_of_subdivisions;

        if constexpr (Dimension == 1) {
            return index;
        } else if constexpr (Dimension == 2) {
            const auto & nx = n[0];

            const auto j = index / nx;
            const auto i = index - (j*nx);

            return {i,j};
        } else {
            const auto & nx = n[0];
            const auto & ny = n[1];

            const auto k = index / (nx*ny);
            const auto j = (index - (k*nx*ny)) / nx;
            const auto i = index - ((k*nx*ny) + (j*nx));

            return {i, j, k};
        }
    }

    /** Get the grid location of the cell that contains the given world coordinates */
    inline GridCoordinates
    grid_coordinates_at(const WorldCoordinates & coordinates) const noexcept
    {
        // @todo (jnbrunet2000@gmail.com): This test should be using inverse mapping function from a regular
        //  hexahedron geometric element defined in the geometry module.

        return (coordinates - m_anchor_position)
        .direct_division(H());
    }

    /** Test if the position of a given point is inside this grid */
    inline bool
    contains_position(const WorldCoordinates & coordinates) const noexcept
    {
        // @todo (jnbrunet2000@gmail.com): This test should be using inverse mapping function from a regular
        //  hexahedron geometric element defined in the geometry module.

        const auto distance_to_anchor = (coordinates - m_anchor_position).direct_division(size());

        if (distance_to_anchor[0] < 0 || distance_to_anchor[0] > 1)
            return false;

        if constexpr (Dimension >= 2) {
            if (distance_to_anchor[1] < 0 || distance_to_anchor[1] > 1)
                return false;
        }

        if constexpr (Dimension == 3) {
            if (distance_to_anchor[2] < 0 || distance_to_anchor[2] > 1)
                return false;
        }

        return true;
    }

protected:
    ///< Position of the anchor point of this grid.
    const WorldCoordinates m_anchor_position;

    ///< Number of sub-cells in the x, y and z directions respectively.
    const Subdivisions m_number_of_subdivisions;

    ///<  Dimension of the grid from the anchor point in the x, y and z directions respectively.
    const Dimensions m_size;

private:
    const inline GridType &
    Self() const
    {
        return static_cast<const GridType &> (*this);
    }

};

} // namespace internal
} // namespace engine
} // namespace topology
} // namespace caribou

#endif //CARIBOU_TOPOLOGY_ENGINE_GRID_INTERNAL_GRID_H
