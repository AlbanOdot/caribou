#include <Caribou/Topology/Engine/Grid/Grid.h>

namespace caribou
{

namespace topology
{

namespace engine
{


template <>
Grid<2>::Index
Grid<2>::cell_index(const VecInt & grid_coordinates) const
{
    const VecInt::ValueType & i = grid_coordinates[0];
    const VecInt::ValueType & j = grid_coordinates[1];

    const auto & n = number_of_subdivision();
    const auto & nx = n[0];
    const auto & ny = n[1];

    if (i > nx-1 || j > ny-1) {
        throw std::out_of_range(
                "Trying to access a cell at an invalid grid coordinate (" + std::to_string(i) + ", " + std::to_string(j) + ")"
        );
    }

    // Index is generated by looking at the cells as a flatten array
    return j*nx + i;
};

template <>
Grid<2>::VecInt
Grid<2>::grid_coordinates(const Index & cell_index) const
{
    const auto & n = number_of_subdivision();
    const auto & nx = n[0];

    const Index j = cell_index / nx;
    const Index i = cell_index - (j*nx);

    return {i, j};
};

template <>
std::array<typename Grid<2>::Index, Grid<2>::NumberOfNodes>
Grid<2>::nodes(const VecInt & grid_coordinates) const
{
    const VecInt::ValueType & i = grid_coordinates[0];
    const VecInt::ValueType & j = grid_coordinates[1];

    const auto & n = number_of_subdivision();
    const auto & nx = n[0];
    const auto & ny = n[1];

    if (i > nx-1 || j > ny-1) {
        throw std::out_of_range(
                "Trying to access a cell at an invalid grid coordinate (" + std::to_string(i) + ", " + std::to_string(j) + ")"
        );
    }

    return {
            j*(nx + 1) + i,
            j*(nx + 1) + i + 1,
            (j+1)*(nx + 1) + i,
            (j+1)*(nx + 1) + i + 1
    };
};

template <>
Grid<2>::VecFloat
Grid<2>::position(const Index & node_id) const
{
    
};

template <>
Grid<2>::Grid(VecFloat anchor, VecInt subdivisions, VecFloat dimensions)
        : anchor(anchor), nSubdivisions(subdivisions), dimensions(dimensions)
{
    const auto & nx = subdivisions[0];
    const auto & ny = subdivisions[1];

    // Here we loop on the z, y and x order to proper align in memory cells so that when loping in the inverse
    // order (x and y), the cells are closer to each other in the memory
    cells.resize(nx*ny);
    for (size_t j = 0; j < ny; ++j) {
        for (size_t i = 0; i < nx; ++i) {
            Index index = cell_index({i, j});
            cells[index].reset(new Cell<2> (this, index));
        }
    }
};

} // namespace engine

} // namespace topology

} // namespace caribou