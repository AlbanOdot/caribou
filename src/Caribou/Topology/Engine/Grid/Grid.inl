#ifndef CARIBOU_TOPOLOGY_ENGINE_GRID_GRID_INL
#define CARIBOU_TOPOLOGY_ENGINE_GRID_GRID_INL

#include <Caribou/Topology/Engine/Grid/Grid.h>

namespace caribou
{

namespace topology
{

namespace engine
{

template <class TCell>
Grid<TCell>::Grid(VecFloat anchor, VecInt subdivisions, VecFloat dimensions)
        : m_anchor(anchor), m_number_of_subdivisions(subdivisions), m_dimensions(dimensions)
{
    using Int = typename VecInt::ValueType;

    const Int & nx = subdivisions[0];
    const Int & ny = subdivisions[1];
    const Int   nz = (Dimension == 3) ? subdivisions[2] : 1;

    // Here we loop on the z, y and x order to proper align in memory cells so that when loping in the inverse
    // order (x, y and z), the cells are closer to each other in the memory
    m_cells.resize(nz*ny*nx);
    for (size_t k = 0; k < nz; ++k) {
        for (size_t j = 0; j < ny; ++j) {
            for (size_t i = 0; i < nx; ++i) {
                Index index = cell_index({i, j, k});
                m_cells[index] = CellType (index);
            }
        }
    }
}

template <class TCell>
typename Grid<TCell>::Index
Grid<TCell>::cell_index(const typename Grid<TCell>::VecInt & grid_coordinates) const
{
    using Int = typename VecInt::ValueType;

    const Int & i = grid_coordinates[0];
    const Int & j = grid_coordinates[1];
    const Int   k = (Dimension == 3) ? grid_coordinates[2] : 0;


    const VecInt & n = number_of_subdivision();
    const Int & nx = n[0];
    const Int & ny = n[1];
    const Int   nz = (Dimension == 3) ? n[2] : 1;

    if (i > nx-1 || j > ny-1 || k > nz-1) {
        throw std::out_of_range("Trying to access a cell at an invalid grid coordinate " + grid_coordinates.to_string());
    }

    // Index is generated by looking at the cells as a flatten array
    return k*ny*nx + j*nx + i;
}

template <class TCell>
typename Grid<TCell>::VecInt
Grid<TCell>::grid_coordinates(const Index & cell_index) const
{
    using Int = typename VecInt::ValueType;

    const VecInt & n = number_of_subdivision();
    const Int & nx = n[0];
    const Int & ny = n[1];

    const Index k = (Dimension == 3) ? (cell_index / (nx*ny)) : 0;
    const Index j = (cell_index - (k*nx*ny)) / nx;
    const Index i = cell_index - ((k*nx*ny) + (j*nx));

    if (Dimension == 2)
        return {i, j};
    else // Dimension == 3
        return {i, j, k};
}

template <class TCell>
std::array<typename Grid<TCell>::Index, Grid<TCell>::NumberOfNodes>
Grid<TCell>::nodes(const VecInt & grid_coordinates) const
{
    using Int = typename VecInt::ValueType;

    const Int & i = grid_coordinates[0];
    const Int & j = grid_coordinates[1];
    const Int   k = (Dimension == 3) ? grid_coordinates[2] : 0;


    const VecInt & n = number_of_subdivision();
    const Int & nx = n[0]+1; // Number of nodes in the x direction
    const Int & ny = n[1]+1; // Number of nodes in the y direction
    const Int   nz = (Dimension == 3) ? n[2]+1 : 1; // Number of nodes in the z direction

    if (i > nx-1 || j > ny-1 || k > nz-1) {
        throw std::out_of_range("Trying to access a cell at an invalid grid coordinate " + grid_coordinates.to_string());
    }

    std::array<typename Grid<TCell>::Index, Grid<TCell>::NumberOfNodes> node_list;

    node_list[0] = (k+0)*ny*nx + (j+0)*nx + (i+0);
    node_list[1] = (k+0)*ny*nx + (j+0)*nx + (i+1);
    node_list[2] = (k+0)*ny*nx + (j+1)*nx + (i+1);
    node_list[3] = (k+0)*ny*nx + (j+1)*nx + (i+0);

    if (Dimension == 3) {
        node_list[4] = (k+1)*ny*nx + (j+0)*nx + (i+0);
        node_list[5] = (k+1)*ny*nx + (j+0)*nx + (i+1);
        node_list[6] = (k+1)*ny*nx + (j+1)*nx + (i+1);
        node_list[7] = (k+1)*ny*nx + (j+1)*nx + (i+0);
    }

    return node_list;
}

template <class TCell>
typename Grid<TCell>::VecFloat
Grid<TCell>::position(const Index & node_id) const
{
    using Int = typename VecInt::ValueType;

    const VecInt & n = number_of_subdivision();
    const Int & nx = n[0]+1; // Number of nodes in the x direction
    const Int & ny = n[1]+1; // Number of nodes in the y direction

    const Index k = (Dimension == 3) ? (node_id / (nx*ny)) : 0; // Node indice in the z direction
    const Index j = (node_id - (k*nx*ny)) / nx; // Node indice in the y direction
    const Index i = node_id - ((k*nx*ny) + (j*nx)); // Node indice in the x direction

    const auto & h = cell_size();
    const auto & hx = h[0]; // Width of a cell
    const auto & hy = h[1]; // Height of a cell
    const auto & hz = h[2]; // Dept of a cell

    // Relative position of the node within the grid
    const VecFloat p = (Dimension == 2) ? VecFloat({i*hx, j*hy}) : VecFloat({i*hx, j*hy, k*hz});

    return m_anchor + p; // World position
}

template <class TCell>
void
Grid<TCell>::subdivide(const Index & cell_index)
{

}

} // namespace engine

} // namespace topology

} // namespace caribou

#endif //CARIBOU_TOPOLOGY_ENGINE_GRID_GRID_INL
