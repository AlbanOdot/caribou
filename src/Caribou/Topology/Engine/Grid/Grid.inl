#ifndef CARIBOU_TOPOLOGY_ENGINE_GRID_GRID_INL
#define CARIBOU_TOPOLOGY_ENGINE_GRID_GRID_INL

#include <Caribou/Topology/Engine/Grid/Grid.h>
#include <array>

namespace caribou
{

namespace topology
{

namespace engine
{


Grid::Index
Grid::cell_index(const typename Grid::VecInt & grid_coordinates) const
{
    const VecInt & n = number_of_subdivision();

    const Int & i = grid_coordinates[0];
    const Int & j = grid_coordinates[1];
    const Int   k = (Dimension == 3) ? grid_coordinates[2] : 0;

    const Int & nx = n[0];
    const Int & ny = n[1];
    const Int   nz = (Dimension == 3) ? n[2] : 1;

    if (i > nx-1 || j > ny-1 || k > nz-1) {
        throw std::out_of_range("Trying to access a cell at an invalid grid coordinate " + grid_coordinates.to_string());
    }

    // Index is generated by looking at the cells as a flatten array
    return k*ny*nx + j*nx + i;
}

template <class TCell>
typename Grid<TCell>::VecInt
Grid<TCell>::grid_coordinates(const Index & cell_index) const
{
    using Int = typename VecInt::ValueType;

    const VecInt & n = number_of_subdivision();
    const Int & nx = n[0];
    const Int & ny = n[1];

    const Index k = (Dimension == 3) ? (cell_index / (nx*ny)) : 0;
    const Index j = (cell_index - (k*nx*ny)) / nx;
    const Index i = cell_index - ((k*nx*ny) + (j*nx));

    if (CONSTEXPR_IF(Dimension == 2))
        return {i, j};
    else // Dimension == 3
        return {i, j, k};
}

template <class TCell>
std::array<typename Grid<TCell>::Index, Grid<TCell>::NumberOfNodes>
Grid<TCell>::nodes(const VecInt & grid_coordinates) const
{
    using Int = typename VecInt::ValueType;

    const Int & i = grid_coordinates[0];
    const Int & j = grid_coordinates[1];
    const Int   k = (Dimension == 3) ? grid_coordinates[2] : 0;


    const VecInt & n = number_of_subdivision();
    const Int & nx = n[0]+1; // Number of nodes in the x direction
    const Int & ny = n[1]+1; // Number of nodes in the y direction
    const Int   nz = (Dimension == 3) ? n[2]+1 : 1; // Number of nodes in the z direction

    if (i > nx-1 || j > ny-1 || k > nz-1) {
        throw std::out_of_range("Trying to access a cell at an invalid grid coordinate " + grid_coordinates.to_string());
    }

    std::array<typename Grid<TCell>::Index, Grid<TCell>::NumberOfNodes> node_list;

    node_list[0] = (k+0)*ny*nx + (j+0)*nx + (i+0);
    node_list[1] = (k+0)*ny*nx + (j+0)*nx + (i+1);
    node_list[2] = (k+0)*ny*nx + (j+1)*nx + (i+1);
    node_list[3] = (k+0)*ny*nx + (j+1)*nx + (i+0);

    if (CONSTEXPR_IF(Dimension == 3)) {
        node_list[4] = (k+1)*ny*nx + (j+0)*nx + (i+0);
        node_list[5] = (k+1)*ny*nx + (j+0)*nx + (i+1);
        node_list[6] = (k+1)*ny*nx + (j+1)*nx + (i+1);
        node_list[7] = (k+1)*ny*nx + (j+1)*nx + (i+0);
    }

    return node_list;
}

template <class TCell>
typename Grid<TCell>::VecFloat
Grid<TCell>::position(const Index & node_id) const
{
    using Int = typename VecInt::ValueType;

    const VecInt & n = number_of_subdivision();
    const Int & nx = n[0]+1; // Number of nodes in the x direction
    const Int & ny = n[1]+1; // Number of nodes in the y direction

    const Index k = (Dimension == 3) ? (node_id / (nx*ny)) : 0; // Node indice in the z direction
    const Index j = (node_id - (k*nx*ny)) / nx; // Node indice in the y direction
    const Index i = node_id - ((k*nx*ny) + (j*nx)); // Node indice in the x direction

    const auto & h = cell_size();
    const auto & hx = h[0]; // Width of a cell
    const auto & hy = h[1]; // Height of a cell
    const auto & hz = h[2]; // Dept of a cell

    // Relative position of the node within the grid
    const VecFloat p = (Dimension == 2) ? VecFloat({i*hx, j*hy}) : VecFloat({i*hx, j*hy, k*hz});

    return m_anchor + p; // World position
}

template <class TCell>
std::array<typename Grid<TCell>::VecFloat, TCell::NumberOfNodes>
Grid<TCell>::positions(const CellType & cell)
{
    // Position of the anchor node (node #0 in a hexa) of the sub-cell relative to its outer cell position
    // (the top-cell without parent that contains it)
    VecFloat anchor_subcell_node_position = (Dimension == 2) ? VecFloat({0, 0}) : VecFloat({0, 0, 0});

    // To find the anchor node position in the outer cell, we first need to compute its relative position in each of its parent cell
    const CellType * current_cell = &cell;
    while (current_cell->has_parent()) {
        Index index = current_cell->index();
        Index L = current_cell->level();
        // The width (resp. height, resp. depth) of a sub-cell at level L is the width (resp. height, resp. depth)
        // of the outer cell at level 0 divided by 2^L. We use this to accumulate the position of the node 0 in the current cell's parent.

        // First, let's find the "grid" position of the node 0 in its parent cell
        const Index nx = CellType::Nx; // Number of cells in the x direction
        const Index ny = CellType::Ny; // Number of cells in the y direction

        const Index k = (Dimension == 3) ? (index / (nx*ny)) : 0; // Node indice in the z direction
        const Index j = (index - (k*nx*ny)) / nx; // Node indice in the y direction
        const Index i = index - ((k*nx*ny) + (j*nx)); // Node indice in the x direction

        // Next, we got two choice per axis. If the node 0 of the current cell is placed on the node 0 of its parent
        // cell, we add nothing to anchor_node_position. If it is position on the second node, we add cell-width / 2
        // which is equal to outer cell width / (2^L)

        anchor_subcell_node_position[0] += (i==0) ? 0. : 1. / (1 << L); // 1 / 2^L
        anchor_subcell_node_position[1] += (j==0) ? 0. : 1. / (1 << L); // 1 / 2^L

        if (Dimension == 3)
            anchor_subcell_node_position[2] += (k==0) ? 0. : 1. / (1 << L); // 1 / 2^L

        current_cell = &current_cell->parent();
    }

    const VecFloat H = cell_size(); // Width, height and depth of the outer cell
    const VecInt D = grid_coordinates(current_cell->index()); // Outer cell's coordinate in the grid

    // Scale the anchor position of the inner-cell with the real dimension of its outer-cell
    anchor_subcell_node_position = anchor_subcell_node_position.direct_mult(H);

    // Position of the anchor node of the outer-cell relative to the grid'anchor
    VecFloat anchor_cell_node_position = H.direct_mult(D);

    // Compute the world position of the anchor node of the sub-cell
    anchor_subcell_node_position = m_anchor + anchor_cell_node_position + anchor_subcell_node_position;

    // Finally, compute the remaining nodes of the sub-cell from its anchor node and its width, height and depth
    std::array<VecFloat, CellType::NumberOfNodes> nodes;

    const VecFloat h = H / (1 << cell.level()); // sub-cell dimension = outer-cell dimension / 2^L
    const VecFloat dx = (Dimension == 3) ? VecFloat(h[0],  0,   0) :  VecFloat(h[0],  0);
    const VecFloat dy = (Dimension == 3) ? VecFloat(  0, h[1],  0) :  VecFloat(  0, h[1]);
    const VecFloat dz = (Dimension == 3) ? VecFloat(  0,   0, h[2]) : VecFloat(  0,   0);

    nodes[0] = anchor_subcell_node_position;
    nodes[1] = anchor_subcell_node_position + dx;
    nodes[2] = anchor_subcell_node_position + dx + dy;
    nodes[3] = anchor_subcell_node_position + dy;

    if (Dimension == 3) {
        nodes[4] = nodes[0] + dz;
        nodes[5] = nodes[1] + dz;
        nodes[6] = nodes[2] + dz;
        nodes[7] = nodes[3] + dz;
    }
    return nodes;
}

template <class TCell>
typename Grid<TCell>::CellType *
Grid<TCell>::right_cell_of(const CellType & cell)
{
    if (cell.has_parent()) {
        
    }
}

} // namespace engine

} // namespace topology

} // namespace caribou

#endif //CARIBOU_TOPOLOGY_ENGINE_GRID_GRID_INL
