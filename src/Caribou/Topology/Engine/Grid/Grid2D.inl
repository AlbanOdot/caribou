#include <Caribou/Topology/Engine/Grid/Grid.h>

namespace caribou
{

namespace topology
{

namespace engine
{


template <class TCell>
typename Grid<2, TCell>::Index
Grid<2, TCell>::cell_index(const typename Grid<2, TCell>::VecInt & grid_coordinates) const
{
    const VecInt::ValueType & i = grid_coordinates[0];
    const VecInt::ValueType & j = grid_coordinates[1];

    const auto & n = number_of_subdivision();
    const auto & nx = n[0];
    const auto & ny = n[1];

    if (i > nx-1 || j > ny-1) {
        throw std::out_of_range(
                "Trying to access a cell at an invalid grid coordinate (" + std::to_string(i) + ", " + std::to_string(j) + ")"
        );
    }

    // Index is generated by looking at the cells as a flatten array
    return j*nx + i;
}

template <class TCell>
typename Grid2D<TCell>::VecInt
Grid2D<TCell>::grid_coordinates(const Index & cell_index) const
{
    const auto & n = number_of_subdivision();
    const auto & nx = n[0];

    const Index j = cell_index / nx;
    const Index i = cell_index - (j*nx);

    return {i, j};
}

template <class TCell>
std::array<typename Grid2D<TCell>::Index, Grid2D<TCell>::NumberOfNodes>
Grid2D<TCell>::nodes(const VecInt & grid_coordinates) const
{
    const VecInt::ValueType & i = grid_coordinates[0];
    const VecInt::ValueType & j = grid_coordinates[1];

    const auto & n = number_of_subdivision();
    const auto & nx = n[0]+1; // Number of nodes in the x direction
    const auto & ny = n[1]+1; // Number of nodes in the y direction

    if (i > nx || j > ny) {
        throw std::out_of_range(
                "Trying to access a cell at an invalid grid coordinate (" + std::to_string(i) + ", " + std::to_string(j) + ")"
        );
    }

    return {
            (j+0)*nx + (i+0),
            (j+0)*nx + (i+1),
            (j+1)*nx + (i+1),
            (j+1)*nx + (i+0)
    };
}

template <class TCell>
typename Grid2D<TCell>::VecFloat
Grid2D<TCell>::position(const Index & node_id) const
{
    const auto & n = number_of_subdivision();
    const auto & nx = n[0]+1; // Number of nodes in the x direction

    const Index j = node_id / nx;     // Node indice in the x direction
    const Index i = node_id - (j*nx); // Node indice in the y direction

    const auto & h = cell_size();
    const auto & hx = h[0]; // Width of a cell
    const auto & hy = h[1]; // Height of a cell

    // Relative position of the node within the grid
    const VecFloat p = {
        i*hx,
        j*hy
    };

    return anchor + p; // World position
}

template <class TCell>
Grid2D<TCell>::Grid(VecFloat anchor, VecInt subdivisions, VecFloat dimensions)
        : anchor(anchor), nSubdivisions(subdivisions), dimensions(dimensions)
{
    const auto & nx = subdivisions[0];
    const auto & ny = subdivisions[1];

    // Here we loop on the z, y and x order to proper align in memory cells so that when loping in the inverse
    // order (x and y), the cells are closer to each other in the memory
    cells.resize(nx*ny);
    for (size_t j = 0; j < ny; ++j) {
        for (size_t i = 0; i < nx; ++i) {
            Index index = cell_index({i, j});
            cells[index].reset(new CellType (this, index));
        }
    }
}

} // namespace engine

} // namespace topology

} // namespace caribou