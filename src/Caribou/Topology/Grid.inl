#ifndef CARIBOU_TOPOLOGY_GRID_INL
#define CARIBOU_TOPOLOGY_GRID_INL

#include <Caribou/Topology/Grid.h>

namespace caribou
{

using namespace geometry;

namespace topology
{

template <char Dimension>
Grid<Dimension>* Cell<Dimension>::
subdivide (VecInt subdivisions)
{
    if (!is_a_leaf()) {
        throw std::logic_error("Trying to subdivide an already subdivided cell.");
    }

};

template <char Dimension>
typename Cell<Dimension>::VecFloat
Cell<Dimension>::size () const
{
    return m_parent->cell_size();
};

template <char Dimension>
Cell<Dimension> &
Grid<Dimension>::get (const VecInt &grid_coordinates)
{
    return *(cells[cell_index(grid_coordinates)]);
};

template <>
Grid<2>::Index
Grid<2>::cell_index(const VecInt & grid_coordinates) const
{
    const VecInt::ValueType & i = grid_coordinates[0];
    const VecInt::ValueType & j = grid_coordinates[1];

    const auto & n = number_of_subdivision();
    const auto & nx = n[0];
    const auto & ny = n[1];

    if (i > nx-1 || j > ny-1) {
        throw std::out_of_range(
                "Trying to access a cell at an invalid grid coordinate (" + std::to_string(i) + ", " + std::to_string(j) + ")"
        );
    }

    // Index is generated by looking at the cells as a flatten array
    return j*nx + i;
};

template <>
Grid<3>::Index
Grid<3>::cell_index(const VecInt & grid_coordinates) const
{
    const VecInt::ValueType & i = grid_coordinates[0];
    const VecInt::ValueType & j = grid_coordinates[1];
    const VecInt::ValueType & k = grid_coordinates[2];

    const auto & n = number_of_subdivision();
    const auto & nx = n[0];
    const auto & ny = n[1];
    const auto & nz = n[2];

    if (i > nx-1 || j > ny-1 || k > nz) {
        throw std::out_of_range(
                "Trying to access a cell at an invalid grid coordinate (" + std::to_string(i) + ", " + std::to_string(j) + "," + std::to_string(k) + ")"
        );
    }

    // Index is generated by looking at the cells as a flatten array
    return k*ny*nx + j*nx + i;
};

template <>
Grid<2>::VecInt
Grid<2>::grid_coordinates(const Index & cell_index) const
{
    const auto & n = number_of_subdivision();
    const auto & nx = n[0];

    const Index j = cell_index / nx;
    const Index i = cell_index - (j*nx);

    return {i, j};
};

template <>
Grid<3>::VecInt
Grid<3>::grid_coordinates(const Index & cell_index) const
{
    const auto & n = number_of_subdivision();
    const auto & nx = n[0];
    const auto & ny = n[1];

    const Index k = cell_index / (nx*ny);
    const Index j = (cell_index - (k*nx*ny)) / nx;
    const Index i = cell_index - ((k*nx*ny) + (j*nx));

    return {i, j, k};
};

template <>
std::array<typename Grid<2>::Index, Grid<2>::NumberOfNodes>
Grid<2>::nodes(const VecInt & grid_coordinates) const
{
    const VecInt::ValueType & i = grid_coordinates[0];
    const VecInt::ValueType & j = grid_coordinates[1];

    const auto & n = number_of_subdivision();
    const auto & nx = n[0];
    const auto & ny = n[1];

    if (i > nx-1 || j > ny-1) {
        throw std::out_of_range(
                "Trying to access a cell at an invalid grid coordinate (" + std::to_string(i) + ", " + std::to_string(j) + ")"
        );
    }

    return {
            j*(nx + 1) + i,
            j*(nx + 1) + i + 1,
            (j+1)*(nx + 1) + i,
            (j+1)*(nx + 1) + i + 1
    };
};

template <>
Grid<2>::Grid(VecFloat anchor, VecInt subdivisions, VecFloat dimensions)
        : anchor(anchor), nSubdivisions(subdivisions), dimensions(dimensions)
{
    const auto & nx = subdivisions[0];
    const auto & ny = subdivisions[1];

    // Here we loop on the z, y and x order to proper align in memory cells so that when loping in the inverse
    // order (x and y), the cells are closer to each other in the memory
    cells.resize(nx*ny);
    for (size_t j = 0; j < ny; ++j) {
        for (size_t i = 0; i < nx; ++i) {
            Index index = cell_index({i, j});
            cells[index].reset(new Cell<2> (this, index));
        }
    }
};

template <>
Grid<3>::Grid(VecFloat anchor, VecInt subdivisions, VecFloat dimensions)
        : anchor(anchor), nSubdivisions(subdivisions), dimensions(dimensions)
{
    const auto & nx = subdivisions[0];
    const auto & ny = subdivisions[1];
    const auto & nz = subdivisions[2];

    // Here we loop on the z, y and x order to proper align in memory cells so that when loping in the inverse
    // order (x, y and z), the cells are closer to each other in the memory
    cells.resize(nz*ny*nx);
    for (size_t k = 0; k < nz; ++k) {
        for (size_t j = 0; j < ny; ++j) {
            for (size_t i = 0; i < nx; ++i) {
                Index index = cell_index({i, j, k});
                cells[index].reset(new Cell<3> (this, index));
            }
        }
    }
};

} // namespace topology

} // namespace caribou

#endif //CARIBOU_TOPOLOGY_GRID_INL